<!DOCTYPE html>
<html>
  <head>
    <title>title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
#stage {
	width: 400px;
	height: 400px;
}
</style>
  </head>
  <body>
		<canvas id="stage"></canvas>
		<script src="../lib/index.js" type="text/javascript"></script>

		<script id="fragment-shader" type="glsl">
			precision mediump float;

			varying vec2 v_texCoord;

			void main() {
				gl_FragColor = vec4(
					vec3(gl_FragCoord.x / 800.),
					1);
			}
		</script>
		<script id="vertex-shader" type="glsl">
			attribute vec2 position;
			attribute vec2 a_texCoord;
			
			varying vec2 v_texCoord;

			void main() {
				gl_Position = vec4(position, 0, 1);
				v_texCoord = a_texCoord;
			}
		</script>
		<script type="text/javascript">
			const stage = document.getElementById('stage');
			const gl = stage.getContext('webgl');

			if (gl == null) {
				throw new Error("WebGL not supported");
			}

			const image = new Image();
			image.src = "./assets/img.png";
			image.onload = () => render(image, gl);

			function render(image, gl) {
				resize(gl.canvas);
				gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

				const vertexShaderSource =
					document.getElementById("vertex-shader").text;
				const vertexShader =
					createShader(
						gl,
						gl.VERTEX_SHADER,
						vertexShaderSource);

				const fragmentShaderSource =
					document.getElementById("fragment-shader").text;
				const fragmentShader =
					createShader(
						gl,
						gl.FRAGMENT_SHADER,
						fragmentShaderSource);

				const program =
					createProgram(gl, [vertexShader, fragmentShader]);

				const attributes = [
					{
						identifier: 'position',
						type: 'vec2',
						buffer: createBuffer(
							gl,
							new Float32Array([
								-1, -1,
								1, -1,
								-1, 1,
								-1, 1,
								1, -1,
								1, 1
							]),
							gl.STATIC_DRAW)
					},
					{
						identifier: 'a_texCoord',
						type: 'vec2',
						buffer: createBuffer(
							gl,
							new Float32Array([
								0, 0,
								1, 0,
								0, 1,
								0, 1,
								1, 0,
								1, 1,
							]),
							gl.STATIC_DRAW)
					},
				]
					.map(({ identifier, buffer, type }) => ({
						[identifier]: {
							location: gl.getAttribLocation(program, identifier),
							buffer,
							type
						}
					}))
					.reduce((acc, elm) => Object.assign(acc, elm), {});

				gl.useProgram(program);

				Object.keys(attributes)
					.forEach(iden => gl.enableVertexAttribArray(attributes[iden].location));

				bindVertexAttribute(gl, attributes['position'], false);
				bindVertexAttribute(gl, attributes['a_texCoord'], false);

				/*
				const imageTexture =
					createAndSetupTexture(gl);

				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
				*/

				const primitiveType = gl.TRIANGLES;
				const drawOffset = 0;
				const drawCount = 6;
				gl.drawArrays(primitiveType, drawOffset, drawCount);


				/*
				// TODO: here
				const textures = [];
				const framebuffers = [];
				const framebufferCount = 2;
				for (let i = 0; i < framebufferCount; i++) {
					const texture = createTexture(gl);
					textures.push(texture);
					gl.texImage2D(
						gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0,
						g.RGBA, gl.UNSIGNED_BYTE, null);

					const framebuffer = gl.createFramebuffer();
					framebuffers.push(framebuffer);
					gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
					gl.framebufferTexture2D(
						gl.FRAMEBUFFER,
						gl.COLOR_ATTACHMENT0,
						gl.TEXTURE_2D,
						texture,
						0);
				}

				// Define several convolution kernels
				var kernels = {
					normal: [
						0, 0, 0,
						0, 1, 0,
						0, 0, 0
					],
					gaussianBlur: [
						0.045, 0.122, 0.045,
						0.122, 0.332, 0.122,
						0.045, 0.122, 0.045
					],
					unsharpen: [
						-1, -1, -1,
						-1,  9, -1,
						-1, -1, -1
					],
					emboss: [
						-2, -1,  0,
						-1,  1,  1,
						0,  1,  2
					]
				};

				// List of effects to apply.
				var effectsToApply = [
					"gaussianBlur",
					"emboss",
					"gaussianBlur",
					"unsharpen"
				];
*/


				// gl.bindTexture(gl.TEXTURE_2D, imageTexture);
			}

			function createProgram(gl, shaders) {
				const program = gl.createProgram();
				shaders.forEach(shader => gl.attachShader(program, shader));
				gl.linkProgram(program);
				if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
					return program;
				} else {
					console.log(gl.getProgramInfoLog(program));
					gl.deleteProgram(program);
				}
			}

			function createShader(gl, type, source) {
				const shader = gl.createShader(type);
				gl.shaderSource(shader, source);
				gl.compileShader(shader);
				if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					return shader;
				} else {
					console.log(gl.getShaderInfoLog(shader));
					gl.deleteShader(shader);
					return null;
				}
			}

			// https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
			function resize(canvas) {
				var realToCSSPixels = window.devicePixelRatio;

				// Lookup the size the browser is displaying the canvas in CSS pixels
				// and compute a size needed to make our drawingbuffer match it in
				// device pixels.
				var displayWidth =
					Math.floor(canvas.clientWidth * realToCSSPixels);
				var displayHeight =
					Math.floor(canvas.clientHeight * realToCSSPixels);

				// Check if the canvas is not the same size.
				if (canvas.width !== displayWidth ||
					canvas.height !== displayHeight) {

					// Make the canvas the same size
					canvas.width = displayWidth;
					canvas.height = displayHeight;
				}
			}

			function createAndSetupTexture(gl) {
				const texture =
					gl.createTexture();
				gl.bindTexture(
					gl.TEXTURE_2D,
					texture);
				gl.texParameteri(
					gl.TEXTURE_2D,
					gl.TEXTURE_WRAP_S,
					gl.CLAMP_TO_EDGE);
				gl.texParameteri(
					gl.TEXTURE_2D,
					gl.TEXTURE_WRAP_T,
					gl.CLAMP_TO_EDGE);
				gl.texParameteri(
					gl.TEXTURE_2D,
					gl.TEXTURE_MIN_FILTER,
					gl.NEAREST);
				gl.texParameteri(
					gl.TEXTURE_2D,
					gl.TEXTURE_MAG_FILTER,
					gl.NEAREST);
				return texture;
			}

			function bindVertexAttribute(gl, { buffer, location, type }, normalize) {
				if (type !== 'vec2') {
					throw new Error("Unsupported attribute type");
				}

				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				gl.vertexAttribPointer(location, 2, gl.FLOAT, normalize, 0, 0);
			}

			function createBuffer(gl, data, hint) {
				const buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				gl.bufferData(gl.ARRAY_BUFFER, data, hint);
				return buffer;
			}




		</script>
  </body>
</html>
